// Market Data Fetcher - å”èª¿æ‰€æœ‰æ•¸æ“šæº
const YahooFinanceAdapter = require('./sources/yahoo');
const RSSAdapter = require('./sources/rss');
const fs = require('fs');
const path = require('path');

class MarketDataFetcher {
  constructor(config) {
    this.config = config;
    this.yahooAdapter = new YahooFinanceAdapter(config);
    this.rssAdapters = [];
    
    // åˆå§‹åŒ– RSS adapters
    this.initRSSAdapters();
  }

  initRSSAdapters() {
    // å°è‚¡æ–°èž
    if (this.config.data_sources.tw_news) {
      this.config.data_sources.tw_news
        .filter(source => source.enabled)
        .forEach(source => {
          this.rssAdapters.push(
            new RSSAdapter(source.name, source.url, this.config)
          );
        });
    }

    // åœ‹éš›æ–°èž
    if (this.config.data_sources.intl_news) {
      this.config.data_sources.intl_news
        .filter(source => source.enabled)
        .forEach(source => {
          this.rssAdapters.push(
            new RSSAdapter(source.name, source.url, this.config)
          );
        });
    }
  }

  async fetchAllNews() {
    const results = [];
    
    for (const adapter of this.rssAdapters) {
      try {
        const result = await adapter.fetchNews();
        results.push(result);
      } catch (err) {
        console.error(`[${adapter.name}] æŠ“å–å¤±æ•—:`, err.message);
      }
    }

    // åˆä½µæ‰€æœ‰æ–°èž
    const allArticles = results.flatMap(r => r.data);
    
    // å„²å­˜åˆ° cache
    const cacheFile = path.join(__dirname, '../data/cache/news-raw.json');
    const cache = this.loadCache(cacheFile);
    const newArticles = allArticles.filter(article => 
      !cache.some(cached => cached.guid === article.guid)
    );
    
    if (newArticles.length > 0) {
      cache.push(...newArticles);
      fs.writeFileSync(cacheFile, JSON.stringify(cache, null, 2));
      console.log(`âœ… æ–°å¢ž ${newArticles.length} å‰‡æ–°èžåˆ°å¿«å–`);
    } else {
      console.log(`â„¹ï¸  ç„¡æ–°å¢žæ–°èž`);
    }

    return {
      total: allArticles.length,
      new: newArticles.length,
      cached: cache.length
    };
  }

  async fetchMarketData() {
    const results = {};

    // å°è‚¡
    if (this.config.data_sources.market_data.tw_stock.enabled) {
      try {
        const symbol = this.config.data_sources.market_data.tw_stock.symbol;
        results.tw_stock = await this.yahooAdapter.fetchMarketData(symbol);
        
        if (this.config.technical_indicators.enabled) {
          results.tw_stock_indicators = await this.yahooAdapter.fetchTechnicalIndicators(
            symbol,
            this.config.technical_indicators
          );
        }
      } catch (err) {
        console.error('[å°è‚¡æ•¸æ“š] æŠ“å–å¤±æ•—:', err.message);
      }
    }

    // ç¾Žè‚¡
    if (this.config.data_sources.market_data.us_stock.enabled) {
      try {
        const symbols = this.config.data_sources.market_data.us_stock.symbols;
        results.us_stock = {};
        
        for (const symbol of symbols) {
          const data = await this.yahooAdapter.fetchMarketData(symbol);
          const key = symbol.replace('^', '').toLowerCase();
          results.us_stock[key] = data;
        }
      } catch (err) {
        console.error('[ç¾Žè‚¡æ•¸æ“š] æŠ“å–å¤±æ•—:', err.message);
      }
    }

    // åŒ¯çŽ‡
    if (this.config.data_sources.market_data.fx.enabled) {
      try {
        const pair = this.config.data_sources.market_data.fx.pair;
        results.fx = await this.yahooAdapter.fetchMarketData(pair);
      } catch (err) {
        console.error('[åŒ¯çŽ‡æ•¸æ“š] æŠ“å–å¤±æ•—:', err.message);
      }
    }

    return results;
  }

  loadCache(file) {
    if (fs.existsSync(file)) {
      try {
        return JSON.parse(fs.readFileSync(file, 'utf8'));
      } catch (err) {
        console.error(`âš ï¸  å¿«å–æª”æ¡ˆæå£ž (${file}): ${err.message}`);
        console.log('ðŸ”„ å°‡ä½¿ç”¨ç©ºå¿«å–...');
        return [];
      }
    }
    return [];
  }

  getRecentNews(maxAgeHours = 24) {
    const cacheFile = path.join(__dirname, '../data/cache/news-raw.json');
    const cache = this.loadCache(cacheFile);
    
    const cutoff = Date.now() - (maxAgeHours * 60 * 60 * 1000);
    
    return cache.filter(article => {
      const pubDate = new Date(article.pubDate);
      return pubDate.getTime() > cutoff;
    });
  }
}

module.exports = MarketDataFetcher;
